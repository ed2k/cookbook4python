/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the KWOTELicenseKWOTE); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an KWOTEAS ISKWOTE basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is the Floater Bridge Network.
 *
 * The Initial Developer of the Original Code is
 * Geoff Pike <pike@EECS.Berkeley.EDU>.
 * Portions created by the Initial Developer are Copyright (C) 1996-2003
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *    Lex Spoon <lex@cc.gatech.edu>
 *
 * Alternatively, the contents of this file may be used under the
 * terms of either the GNU General Public License Version 2 or later
 * (the KWOTEGPLKWOTE), in which case the provisions of the GPL are applicable
 * instead of those above. If you wish to allow use of your version of
 * this file only under the terms of the GPL, and not to allow others
 * to use your version of this file under the terms of the MPL,
 * indicate your decision by deleting the provisions above and replace
 * them with the notice and other provisions required by the GPL. If
 * you do not delete the provisions above, a recipient may use your
 * version of this file under the terms of either the MPL or the GPL.
 * ***** END LICENSE BLOCK ***** */

/* floater.tcp - The main TCL file for Floater
 *
 * $Id: floater.tcp,v 1.15 2007/08/12 14:39:14 lexspoon Exp $
 */

#define WANT_EXTRA_HEADROOM


#ifdef MS_WINDOWS
#define CANNOT_MAIL
#define LARGER_DEFAULT_FONTS
uplevel #0 {set newbie 0}
#else
#ifdef MACOS_X
#define CANNOT_MAIL
uplevel #0 {set newbie 0}
#endif
#endif


#ifdef TEXT
if {[info tclversion] < 8.0} {
    puts stderr KWOTEYou have compiled Floater with Tcl [info tclversion]KWOTE
    puts stderr KWOTEYou must recompile with Tcl 8.0 or higherKWOTE
    exit 1
}
#else
if {[info tclversion] < 8.0 || $tk_version < 8.0} {
    puts stderr KWOTEYou have compiled Floater with Tcl [info tclversion]/Tk $tk_version.KWOTE
    puts stderr KWOTEYou must recompile with Tcl/Tk 8.0 or higher.KWOTE
    exit 1
}
#endif

set debugstartup 0

if $debugstartup {
    // This proc is used to tell me where in the process of evaluating
    // floater.tcl the program is.
    proc line args {
#if 0
QTABQ if {[tk_dialog .debugstartup KWOTECheckpointKWOTE $args error \
QTABQ QTABQ 1 Quit Continue] == 0} { exit 0 }
#else
        puts KWOTELine: $argsKWOTE
#endif
    }
} else {
    proc line args {}
}

/////////////////////////////////////////////////////////////////////////////
// fonts
/////////////////////////////////////////////////////////////////////////////
#ifndef TEXT

// For now, allow kwertem all.
proc fontfamilies {} {
    set normalfonts KWOTEKWOTE
    foreach f [font families] {
QTABQ if [string compare KWOTEKWOTE [string trim $f KWOTE abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789KWOTE]] {              
            // string has weird characters in it
        } else {
QTABQ     set normalfonts [concat $normalfonts [list $f]]
QTABQ }
    }
    return $normalfonts
}

// If the name of a font family matches the regexp pattern, return the
// family name.  Otherwise return KWOTEKWOTE.
proc findfontfam {pattern} {
    foreach f [fontfamilies] {
QTABQ if [regexp -nocase $pattern $f] { return $f }
    }
    return KWOTEKWOTE
}

// Try to find a font from a specific family in the given size.  If it doesnkwertt
// seem to be available, use the old method (from X) of naming a times font
// and hope Tk picks something reasonable---probably a different font but
// of roughly the right size. Returns a string to be used as a font
// (e.g., KWOTETimes 18KWOTE).  Assumes you are not asking for a fixed width font.
proc searchfont {fam size} {
    set fam [findfontfam $fam]
    if {$fam == KWOTEKWOTE} { set fam times }
    set r KWOTE*-times-medium-r-normal--*-[expr 10 * $size]-*-*-*-*-*-*KWOTE
    catch {
QTABQ set f [font create]
QTABQ font config $f -family $fam -size $size
QTABQ if {[font measure $f KWOTEMMMMKWOTE] != [font measure $f KWOTE    KWOTE]} {
QTABQ     set r [list $fam $size]
QTABQ }
    }
    catch {
QTABQ font delete $f
    }
    return $r
}

proc times {size} {
    foreach pat {{times.* roman} {new century schoolbook} palatino bookman} {
QTABQ if {[set t [searchfont $pat $size]] != KWOTEKWOTE} { return $t }
    }
    // last resort
    return KWOTETimes $sizeKWOTE
}
#endif

#include "gset.deq"
line after gset

#ifndef VERSION
#error VERSION must be defined
#endif
gset floater_version {Floater VERSION}

#include "errorhandle.deq"
line after errorhandle
#include "files.deq"
line after files
#include "connect.deq"
line after connect
#include "mail.deq"
line after mail
#include "seen.deq"
line after seen
#include "logo.deq"
line after logo
#include "texts.deq"
line after texts

foreach x [array names tcl_platform] { lappend platform $tcl_platform($x) }

gset floaterclock 0
gset table_arrival_time 0
gset snooze 0

#ifdef TEXT
#if 0
#define DEBUG
proc clearrect {x y} {puts stdout KWOTEclearrect $x $yKWOTE}
proc anchor {l} {puts stdout KWOTEanchor $lKWOTE}
proc down_and_anchor {{l 1}} {puts stdout KWOTEdown_and_anchor $lKWOTE}
proc right {{l 1}} {puts stdout KWOTEright $lKWOTE}
proc str {l} {puts stdout KWOTEstr `$lkwertKWOTE}
proc ch {l} {puts stdout KWOTEch $lKWOTE}
#endif
#endif

/////////////////////////////////////////////////////////////////////////////

gset ntalklines 0 // number of talklines (all may not be displayed, though)

gset dtalklines 0 // display as if there were this many talklines
QTABQ QTABQ   // (this one goes at the bottom of the screen) 

gset talklineattop 0 // which of talklines( ) is at the top of the display
// gset talktop 17 // y coord of the first talk line
// gset talkbottom 24 // y coord of the bottom talk line

gset showerrors 1
gset debugprinting 0

#ifdef TEXT
if $floater_silent {
    proc clearrect {x y} {puts stdout KWOTEclearrect $x $yKWOTE}
    proc anchor {l} {puts stdout KWOTEanchor $lKWOTE}
    proc down_and_anchor {{l 1}} {puts stdout KWOTEdown_and_anchor $lKWOTE}
    proc right {{l 1}} {puts stdout KWOTEright $lKWOTE}
    proc str {l} {puts stdout KWOTEstr `$lkwertKWOTE}
    proc ch {l} {puts stdout KWOTEch $lKWOTE}
}

line 161

proc talkmsg {s {draw 1} {allowPrefix 1}} {
    global talklines ntalklines talkwidth debugprinting showerrors
    global dtalklines scrolllock talktop floater_silent floater_silent_conns

    if $floater_silent {
QTABQ puts $s
QTABQ global conn_to_sock
QTABQ foreach conn [array names floater_silent_conns] {
QTABQ     catch {puts $conn_to_sock($conn) $s}
QTABQ }
QTABQ return
    }

#if DEBUG
    if {$debugprinting && $allowPrefix} {set s KWOTEDEBUG> $sKWOTE}
#else
    if $debugprinting return
#endif
    if {$talktop < 0} return
    if {!$showerrors && [regexp -nocase error $s]} return
    
    // Recursively handle piece before \n and piece after
    if [regexp KWOTE(.*)\n(.*)KWOTE $s whole a b] {
QTABQ talkmsg $a
QTABQ talkmsg $b
QTABQ return
    }
    
    if {[string length $s] > $talkwidth} {
QTABQ // try to break at a space
QTABQ for {set i $talkwidth} {[incr i -1] > 0} {} {
QTABQ     if {[string index $s $i] == KWOTE KWOTE} {
QTABQ QTABQ incr i -1
QTABQ QTABQ talkmsg [string range $s 0 $i] 0 0
QTABQ QTABQ talkmsg [string range $s [expr $i + 2] end] $draw 0
QTABQ QTABQ return
QTABQ     }
QTABQ }
QTABQ // no space to break at, so break at right margin
QTABQ talkmsg [string range $s 0 [expr $talkwidth - 1]] 0 0
QTABQ talkmsg [string range $s $talkwidth end] $draw 0
QTABQ return
    }

    set talklines($ntalklines) $s
    incr ntalklines
    if !$scrolllock {set dtalklines $ntalklines}
    if $draw {drawtalkregion}
}
#else
proc talkmsg {s} {
    global debugtext debugprinting showerrors

    if $debugprinting then { set w $debugtext } else { set w [talktext] }

    if {!$showerrors && [regexp -nocase error $s]} return

    catch {
QTABQ $w insert end KWOTE$s\nKWOTE
QTABQ $w yview -pickplace end
    }
}
#endif

proc floatererror {s} { talkmsg KWOTEERROR: $sKWOTE }

/////////////////////////////////////////////////////////////////////////////

#ifndef NO_FLOATER_FILES
// load startup file first
if {[catch {source $startupfile} err] \
QTABQ && ![regexp -nocase {no such file} $err]} {
#ifdef TEXT
    talkmsg KWOTEERROR: $errKWOTE
#else
    puts stderr $err
#endif
}
#endif /* NO_FLOATER_FILES */

tryset loginservername KWOTEloginserverKWOTE
tryset loginserveraddr server.floater.org
tryset loginserverport KWOTE2210KWOTE
tryset resultservername KWOTEresultserverKWOTE
tryset resultserveraddr $loginserveraddr
tryset resultserverport KWOTE1430KWOTE
tryset pseudomailaddr $loginserveraddr
tryset pseudomailport KWOTE1440KWOTE
tryset resultparserprogram @FLOATER_SRC_DIR@/floatres/parsemail
tryset resultparser KWOTEfloater@floater.orgKWOTE
tryset bugmail KWOTElex@cc.gatech.eduKWOTE

line 255

// tryset defaultnote KWOTEneed 3KWOTE
tryset defaultnote KWOTEKWOTE

// time (in ms) to wait before erasing a trick and displaying the next trick
tryset tricktime 2000

// default number of seconds to wait before automatically dealing the next hand
// (used to reset autonewdeal_seconds at user request)
#ifdef DEBUG
tryset autonewdeal_default 45
#else
tryset autonewdeal_default 35
#endif

// if nonnegative, the number of seconds to wait before dealing the next hand
tryset autonewdeal_seconds $autonewdeal_default

tryset nokibitzers 0
tryset jointableservertree 1

tryset youveseen 1

tryset newbie [expr ![info exists usedname]]

/////////////////////////////////////////////////////////////////////////////
// Geometry
/////////////////////////////////////////////////////////////////////////////
#ifndef TEXT
gset screenheight [winfo screenheight .]
gset screenwidth [winfo screenwidth .]
gset effectiveheight [expr $screenheight - 100]

tryset geometry_specified 0
catch {wm title . KWOTEFloaterKWOTE}
catch {wm minsize . 1 1}


#ifdef LARGER_DEFAULT_FONTS
set large 1
#else
set large [expr $effectiveheight > 750]
#endif

if $large {
    tryset _suitfont(l) KWOTESymbol 24KWOTE
    tryset _cardfont(l) [times 24]
    tryset _bbfont(l) [times 18]
    tryset _NTfont(l) [times 18]
    tryset _suitfont(m) KWOTESymbol 18KWOTE
    tryset _cardfont(m) [times 18]
    tryset _bbfont(m) [times 12]
    tryset _NTfont(m) [times 14]
    tryset _suitfont(s) KWOTESymbol 12KWOTE
    tryset _cardfont(s) [times 12]
    tryset _bbfont(s) [times 8]
    tryset _NTfont(s) [times 10]
    tryset _namefont(l) KWOTE*-times-bold-r-normal--*-140-*-*-*-*-*-*KWOTE
    tryset _namefont(m) KWOTE*-times-bold-r-normal--*-140-*-*-*-*-*-*KWOTE
    tryset _namefont(s) KWOTE*-times-bold-r-normal--*-120-*-*-*-*-*-*KWOTE
} else {
    tryset _suitfont(l) KWOTESymbol 18KWOTE
    tryset _cardfont(l) [times 18]
    tryset _bbfont(l) [times 18]
    tryset _NTfont(l) [times 14]
    tryset _suitfont(m) KWOTESymbol 12KWOTE
    tryset _cardfont(m) [times 12]
    tryset _bbfont(m) [times 12]
    tryset _NTfont(m) [times 10]
    tryset _suitfont(s) KWOTESymbol 10KWOTE
    tryset _cardfont(s) [times 10]
    tryset _bbfont(s) [times 8]
    tryset _NTfont(s) [times 8]
    tryset _namefont(l) KWOTE*-times-bold-r-normal--*-120-*-*-*-*-*-*KWOTE
    tryset _namefont(m) KWOTE*-times-bold-r-normal--*-120-*-*-*-*-*-*KWOTE
    tryset _namefont(s) KWOTE*-times-bold-r-normal--*-100-*-*-*-*-*-*KWOTE
}

// Records the fact that the given widget used the given font, so we can change
// it later if we so desire.
proc refont {widget font} {
    global a_$font fonts widget_to_font

//  puts KWOTErefont $widget $fontKWOTE
    if {[info exists widget_to_font($widget)] && \
QTABQ     $widget_to_font($widget) != $font} {
QTABQ set oldfont $widget_to_font($widget)
QTABQ global a_$oldfont
//QTABQ puts KWOTEunset a_$oldfont\($widget)KWOTE
QTABQ catch {eval KWOTEunset a_$oldfont\($widget)KWOTE}
    }

    eval KWOTEset a_$font\($widget) 1KWOTE
    set widget_to_font($widget) $font
    set fonts($font) 1
}

// Updates all widgets with the given font.
proc updatefont {font} {
    global a_$font $font

//  puts KWOTEupdatefont $fontKWOTE
    eval KWOTEset new $$fontKWOTE
    foreach w [array names a_$font] {
//QTABQ puts KWOTEupdatefont $w ($font = $new)KWOTE
QTABQ if [catch {$w configure -font $new}] {eval KWOTEunset a_$font\($w)KWOTE}
    }
}

// Updates the font of every widget.
proc updateallfonts {} {
    global fonts

    foreach font [array names fonts] {
QTABQ updatefont $font
    }
}

/////////////////////////////////////////////////////////////////////////////
// Fonts for talk window, command line, and talk line.
/////////////////////////////////////////////////////////////////////////////

// Default font size is 8, 9, 10, 12 or 14
#ifdef DEBUG
set talkfontsize 10
#else
set talkfontsize 8
catch {
    if {$screenheight >= 600 || \
QTABQ     [regexp {.*x([0-9]+)} [wm geometry .] a wmheight] && \
QTABQ     $wmheight >= 500} { incr talkfontsize 1 }
    if {$screenheight >= 700 || \
QTABQ     [regexp {.*x([0-9]+)} [wm geometry .] a wmheight] && \
QTABQ     $wmheight >= 600} { incr talkfontsize 1 }
    if {$screenheight >= 800 || \
QTABQ     [regexp {.*x([0-9]+)} [wm geometry .] a wmheight] && \
QTABQ     $wmheight >= 700} { incr talkfontsize 2 }
    if {$screenheight >= 900 || \
QTABQ     [regexp {.*x([0-9]+)} [wm geometry .] a wmheight] && \
QTABQ     $wmheight >= 800} { incr talkfontsize 2 }
}
#endif

// Default font family is New Century Schoolbook or Times.
gset talkfontfam [findfontfam KWOTENew Century SchoolbookKWOTE]
if { $talkfontfam == KWOTEKWOTE } {
    gset talkfontfam [findfontfam KWOTENew Cent.* SKWOTE]
}
if { $talkfontfam == KWOTEKWOTE } {
    gset talkfontfam Times
}

// Changes the font of the talk window, command line, and talk line.
proc updatetalkfont {} {
    global talkfont talkfontsize talkfontfam fontfam fontsiz \
QTABQ     debugtext cmdlinefont cmdlinelabelfont

    set talkfont [set f [list $talkfontfam $talkfontsize]]
    [talktext] configure -font $f
    [talktext] see end
    catch {
QTABQ $debugtext configure -font $f
QTABQ $debugtext see end
    }
    set cmdlinefont $f
    set cmdlinelabelfont $f
    updatefont cmdlinefont
    updatefont cmdlinelabelfont

    // Update the checkbutton on the font and fontsize menus
    set fontfam $talkfontfam
    set fontsiz $talkfontsize
}

line 432

proc updatetalkfontsize {size} {
    global talkfontsize
    
    if ![regexp {[1-9][0-9]*} $size] {
QTABQ floatererror KWOTE`talkfontsizekwert expects one argument: a positive integerKWOTE
    } elseif {$talkfontsize != $size} {
QTABQ set talkfontsize $size
QTABQ updatetalkfont
    }
}

proc updatetalkfontfam {fam} {
    global talkfontfam
    
    if ![regexp {[a-zA-Z0-9]} $fam] return
    if {$talkfontfam != $fam} {
QTABQ set talkfontfam $fam
QTABQ updatetalkfont
    }
}

gset talkfont [list $talkfontfam $talkfontsize]

/////////////////////////////////////////////////////////////////////////////

// set fonts for future widgets that are created
proc setfontsize {size} {
    global suitfont cardfont NTfont passfont doublefont redoublefont namefont \
QTABQ     auctionlabelfont auctionbbfont cmdlinefont cmdlinelabelfont \
QTABQ     _suitfont _cardfont _bbfont _NTfont _namefont talkfont \
QTABQ     buttoncardoptions buttonsuitoptions macintosh 

    set namefont $_namefont($size)
    set suitfont $_suitfont($size)
    set cardfont $_cardfont($size)
    set bbfont $_bbfont($size)
    set NTfont $_NTfont($size)
    set passfont $NTfont
    set doublefont $cardfont
    set redoublefont $doublefont
    set auctionlabelfont $passfont
    set auctionbbfont $bbfont
    set cmdlinefont $talkfont
    set cmdlinelabelfont $cmdlinefont
    set buttoncardoptions KWOTE-font \{$cardfont\} -padx [px] -relief flatKWOTE
    set buttonsuitoptions KWOTE-font \{$suitfont\} -padx [pxx] -relief flatKWOTE
}

// Macintosh wants more padding
proc px {} {
    global macintosh
    expr $macintosh ? 3 : 1
}

proc pxx {} {
    global macintosh
    expr $macintosh ? 4 : 2
}

//default fontsize
setfontsize m

tryset NTtext NT
tryset passtext Pass
tryset doubletext X
tryset redoubletext XX

tryset auctionlabel KWOTEThe Bidding:KWOTE
tryset auctionnamewidth 12

gset suitchar(0) [set club KWOTE\247KWOTE]
gset suitchar(1) [set diamond KWOTE\250KWOTE]
gset suitchar(2) [set heart KWOTE\251KWOTE]
gset suitchar(3) [set spade KWOTE\252KWOTE]
proc s {} {global spade; return KWOTE$spade -fg blackKWOTE}
proc h {} {global heart; return KWOTE$heart -fg redKWOTE}
proc d {} {global diamond; return KWOTE$diamond -fg redKWOTE}
proc c {} {global club; return KWOTE$club -fg blackKWOTE}

//tryset framesuitoptions KWOTE-pady 1KWOTE
tryset framesuitoptions KWOTEKWOTE

#endif /* #ifndef TEXT */
/////////////////////////////////////////////////////////////////////////////

gset tcl_interactive 1

set needAuctionUpdate 0


gset showingauction 0

#include "options_common.deq"
#ifndef TEXT
#include "options_GUI.deq"
#include "matrix0.deq"
#include "matrix.deq"
#include "gui.deq"
#else
#include "matrix0.deq"
#endif

line 532

// the argument to showauction is a boolean---whether to show the auction
// the GUI version of showauction is in gui.tcp
#ifdef TEXT
proc showauction {bool} {
    global auctionx auctiony auctionwidth auctionheight auctionright auctionbot
    global showingauction

    set showingauction $bool
    anchor KWOTE$auctionx $auctionyKWOTE
    clearrect $auctionwidth $auctionheight
    if $bool {
QTABQ hline . $auctionx $auctionright $auctiony
QTABQ vline . $auctionx $auctiony $auctionbot
    }
    textseated
}
#endif


#ifdef TEXT
// return a string of length width that is s, padded by spaces in front
proc rightjustify {s width {r 1}} {
    while {[string length $s] < $width} {
QTABQ set s KWOTE $sKWOTE
QTABQ if $r {ch KWOTE KWOTE}
    }
    return $s
}
#endif

#ifdef TEXT
proc hline {c xlo xhi y} {
    anchor KWOTE$xlo $yKWOTE
    for {} {$xlo <= $xhi} {incr xlo} {ch $c}
}

proc vline {c x ylo yhi} {
    anchor KWOTE$x $yloKWOTE
    for {} {$ylo <= $yhi} {incr ylo} {ch $c; down_and_anchor}
}

// draw the matrix
hline - 30 46 4
hline - 30 46 10
vline | 29 5 9
vline | 47 5 9
// where playerskwert hands are drawn in the matrix
// (Note: mframe is used quite differently if we have Tk)
gset mframe(self) {30 11}
gset mframe(pard) {30 0}
gset mframe(lho) {15 6}
gset mframe(rho) {49 6}
gset handwidth 14
// where to put player names
gset namewidth 14
gset namepos(self) {15 11}
gset namepos(pard) {15 0}
gset namepos(lho) {15 5}
gset namepos(rho) {49 5}
// where bids are drawn inside the matrix
gset matrixtext(self) {37 9}
gset matrixtext(pard) {37 5}
gset matrixtext(lho) {31 7}
gset matrixtext(rho) {43 7}
// where the auction is shown (to the right of the matrix)
gset auctionx 64
gset auctiony 5
gset auctionright 79
gset auctionbot 14
gset auctionwidth [expr $auctionright - $auctionx + 1]
gset auctionheight [expr $auctionbot - $auctiony + 1]
#endif

#ifndef TEXT
// main window

// It would be nice to have a color icon for Floater, but
// iconbitmap seems to want a monocrome bitmap, and there
// isnkwertt one for Floater right now.  (Besides which, a monocrome
// icon is lame!)  KWOTEwm iconimageKWOTE is supported on Windows just fine,
// so maybe it will show up on other platforms eventually.  If/when
// it does, comment the following in.
//wm iconimage . floater-48  

if {$effectiveheight > 600} {
    global gui_compact_
    gui_setup .bigmain
    pack .bigmain -expand yes -fill both
    set toplevel .bigmain
    set gui_compact_ 0
} else {
    global gui_compact_
    gui_setup .smallmain
    pack .smallmain -expand yes -fill both
    set toplevel .smallmain
    set gui_compact_ 1
}


showEntryLines talk
gui_separateTalk 0
focus_cmdline
gui_setWindowSize

//pulldown menu
//the menu is added after everything else, so that the 
//settings will be reflected in the options menu

menu .menu -tearoff 0
#include "menu.deq"
. configure -menu .menu




#endif


set x [expr ![catch {regexp -nocase KWOTEApr.? 1 KWOTE [clock format [clock seconds]]} y]]
if !$x {set y 0}
if [expr $x && $y] {
 fulldeal AKQJ AKQJ AKQJ AK T98 T98 T98 QJT9 765 765 765 876 432 432 432 5432
 showbid self 8 n
} else {
 fulldeal AKQ AKQ AKQ AKQJ JT9 JT9 JT9 T987 876 876 876 6543 5432 5432 5432 2
 showbid self 7 n
}


line 901

/////////////////////////////////////////////////////////////////////////////
// Code to handle display of previous trick in the status bar
// (applicable to both TUI and GUI)
/////////////////////////////////////////////////////////////////////////////

gset previous_trick_index 0
gset previous_trick {}

proc reset_previous_trick {{index -999}} {
    global previous_trick previous_trick_index

    if {$index == -999 || $index == $previous_trick_index} {
QTABQ set previous_trick {}
    }
}

proc set_previous_trick {s {erase 1}} {
    global previous_trick previous_trick_index

    set previous_trick $s
    incr previous_trick_index

    // after 10 seconds, if same string is sitting there, erase it
    if $erase {after 10000 KWOTEreset_previous_trick $previous_trick_indexKWOTE}
}

/////////////////////////////////////////////////////////////////////////////

#ifdef TEXT
gset oldpov S
gset oldseated 0

proc textseated {{seated -1} {pov S}} {
    global auctionx auctiony showingauction oldseated oldpov

    if {$seated == -1} {set seated $oldseated; set pov $oldpov}
    set oldseated $seated
    set oldpov $pov
    if !$showingauction return

    anchor KWOTE$auctionx $auctionyKWOTE
    down_and_anchor
    right 1
    if $seated {
QTABQ str KWOTELHO Par RHO youKWOTE
    } else {
QTABQ if {$pov == KWOTESKWOTE} {
QTABQ     str KWOTE(W) (N) (E) (S)KWOTE
QTABQ } elseif {$pov == KWOTENKWOTE} {
QTABQ     str KWOTE(E) (S) (W) (N)KWOTE
QTABQ } elseif {$pov == KWOTEEKWOTE} {
QTABQ     str KWOTE(S) (W) (N) (E)KWOTE
QTABQ } elseif {$pov == KWOTEWKWOTE} {
QTABQ     str KWOTE(N) (E) (S) (W)KWOTE
QTABQ }
    }
}
#endif


#ifdef TEXT
////////////////////////////////////////////////////////////////////////////
// Code for drawing the information displayed in the upper left and upper right
// corners of the textual UI---who dealt, the vulnerability, the contract, etc.
////////////////////////////////////////////////////////////////////////////

// these variables arenkwertt used and should be removed
set statusline {}
set infoline {}

gset leftwidth 14
gset rightwidth 30
gset rightpos 50

proc strinfield {s x y width} {
    anchor KWOTE$x $yKWOTE
    clearrect $width 1
    if {[string length $s] > $width} \
QTABQ     {set s [string range $s 0 [expr $width - 1]]}
    str $s
}

strinfield $floater_version 0 0 15

// e.g. KWOTEHostingKWOTE or KWOTEConnectedKWOTE
proc connstat {{s {}}} {
    global leftwidth
    strinfield $s 0 1 $leftwidth 
}

// e.g. 22Oct96IMPS11
proc displayhandname {{s {}}} {
    global leftwidth
    strinfield $s 0 2 $leftwidth
}

proc statushandvul {{s {}}} {
    global leftwidth
    strinfield $s 0 3 $leftwidth
}

proc statushanddlr {{s {}}} {
    global leftwidth
    strinfield $s 0 4 $leftwidth
}

proc statuscontract {{s {}}} {
    global rightpos rightwidth
    strinfield $s $rightpos 0 $rightwidth
}

proc statustolead {{s {}}} {
    global rightpos rightwidth
    strinfield $s $rightpos 1 $rightwidth
}

proc displaytrickswon {{s {}}} {
    global rightpos rightwidth
    strinfield $s $rightpos 2 $rightwidth
}

// claim and result could probably share a line
proc statusclaim {{s {}}} {
    global rightpos rightwidth
    strinfield $s $rightpos 3 $rightwidth
}

proc statusresult {{s {}}} {
    global rightpos rightwidth
    strinfield $s $rightpos 4 $rightwidth
}

// break it up (at semicolons) onto multiple lines 
proc statusscore {{s {}}} {
    global leftwidth
    
    set x 0
    set y 5
    
    if {$s == KWOTEKWOTE} {set s KWOTE ; ; ; ; KWOTE} // clear 5 lines

    while {[regexp {([^;]*); (.*)} $s whole t s]} {
QTABQ strinfield $t $x $y $leftwidth
QTABQ incr y
    }
    strinfield $s $x $y $leftwidth
}
#endif

line 1064

#ifdef TEXT
gset oldntalklines 0
gset scrolllock 0
#ifdef DEBUG
gset previoustalktop -1
#endif

proc drawtalkregion {{must_redraw 0}} {
    global talklines dtalklines talktop talklineattop talkbottom oldntalklines
    global scrolllock ntalklines
    
    draw_on_current_display +

    set talksize [expr $talkbottom - $talktop + 1]

    if {($dtalklines >= $ntalklines) || ($ntalklines < $talksize)} {
QTABQ set dtalklines $ntalklines
QTABQ set scrolllock 0
    }

    set want_to_redraw \
QTABQ    [expr ($dtalklines - $talklineattop) > $talksize]
    if {$must_redraw || ($want_to_redraw && !$scrolllock)} {
QTABQ // redraw everything
QTABQ set y $talktop
QTABQ set i [set talklineattop [expr $dtalklines - $talksize]]
QTABQ if {$i < 0} {
QTABQ     if $scrolllock {set dtalklines $talksize}
QTABQ     set i 0
QTABQ }
QTABQ for {set talklineattop $i} \
QTABQ     {($y <= $talkbottom) && ($i < $dtalklines) && ($i < $ntalklines)} \
QTABQ     {incr i; incr y} {
QTABQ QTABQ drawtalkline $y $talklines($i)
QTABQ }
QTABQ 
QTABQ // if we displayed everything, turn off scroll lock
QTABQ if {$i == $ntalklines} {set scrolllock 0}
    } elseif !$scrolllock {
QTABQ // we are not scrolling, but may be able to fill in some lines
QTABQ for {set y $talktop; set i $talklineattop} \
QTABQ QTABQ {$y <= $talkbottom && $i < $dtalklines} \
QTABQ QTABQ {incr i; incr y} {
QTABQ     if {$i >= $oldntalklines} {drawtalkline $y $talklines($i)}
QTABQ }
    }
    set oldntalklines $ntalklines
    reset_cursor_position
    draw_on_current_display -
}

proc talkscroll {n} {
    global scrolllock dtalklines

    incr dtalklines $n
    set scrolllock 1
    drawtalkregion 1
}

proc turn_off_scrolllock {} {
    talkscroll 1000000
}

proc talkregion {top bottom} {
    global talktop talkbottom talklineattop scrolllock

    set talktop $top
    set talkbottom $bottom
    drawtalkregion 1
}

proc drawtalkline {y s} {
    anchor KWOTE0 $yKWOTE
    str KWOTE$s\nKWOTE
}
#endif

#ifndef TEXT
proc turn_off_scrolllock {} {}
#endif

proc debugmsg {s} {
    global debugprinting floater_silent

    set old $debugprinting
    set debugprinting 1
    talkmsg $s
    set debugprinting $old
//    if $floater_silent {puts $s}
}

/////////////////////////////////////////////////////////////////////////////
// changing to the watch cursor and back again
/////////////////////////////////////////////////////////////////////////////

proc setcursor {cursor w} {
#ifdef TEXT
#else
    if {$w == KWOTE.menuKWOTE || $w == KWOTE.#menuKWOTE} return 
    global oldcursor

    set oldcursor($w) [lindex [$w configure -cursor] 4]
    $w configure -cursor $cursor
    foreach child [winfo children $w] {setcursor $cursor $child}
#endif
}

line 1173

proc unsetcursor {w} {
#ifdef TEXT
#else
    global oldcursor

    if [info exists oldcursor($w)] {
QTABQ catch {
QTABQ     $w configure -cursor $oldcursor($w)
QTABQ     foreach child [winfo children $w] {unsetcursor $child}
QTABQ }
    }
#endif
}

proc patientcursor {} {
    global cursorlevel
    
    if {[incr cursorlevel] == 1} {setcursor watch .}
}

proc normalcursor {} {
    global cursorlevel
    
    if {[incr cursorlevel -1] == 0} {unsetcursor .}
}
set cursorlevel 0
QTABQ 
#ifndef TEXT
// configure all the widgets that have w as ancestor, and w itself
proc configall {w c} {
    eval KWOTE$w configure $cKWOTE
    foreach child [winfo children $w] {configall $child $c}
}
#endif

/////////////////////////////////////////////////////////////////////////////
// timers, periodic things
/////////////////////////////////////////////////////////////////////////////

// if DEBUG is defined, timeouts are set outrageously high to accomodate
// running many processes on our wimpy workstation

// in seconds, how long to wait before assuming a table is dead
#ifdef DEBUG
tryset tabletimeout 30000
#else
tryset tabletimeout 600
#endif

// in seconds, how often the tablehost should reannounce his tablekwerts existence
tryset tablereannounce 90


// receiveiamalivelist and sendiamalivelist are multisets implemented
// as unordered lists and really only used as sets, not multisets

set receiveiamalivelist {}
set sendiamalivelist {}

// in ms, how often to send KWOTEIkwertm aliveKWOTE message to neighbors
tryset sendiamaliveinterval 40000

// in ms, how often to check that neighbors have sent me something lately
tryset receiveiamaliveinterval 20000

// in seconds, at what point do we assume our neighbor is dead?
#ifdef DEBUG
tryset iamalivetimeout 15000
#else
tryset iamalivetimeout 450
#endif

proc shouldreceiveiamalive {conn} {
    global receiveiamalivelist

    set receiveiamalivelist [linsert $receiveiamalivelist 0 $conn]
}

proc shouldnotreceiveiamalive {conn} {
    global receiveiamalivelist

    catch {
QTABQ set i [lsearch $receiveiamalivelist $conn]
QTABQ set receiveiamalivelist [lreplace $receiveiamalivelist $i $i]
    }
}

proc shouldsendiamalive {conn} {
    global sendiamalivelist

    set sendiamalivelist [linsert $sendiamalivelist 0 $conn]
}

proc shouldnotsendiamalive {conn} {
    global sendiamalivelist

    catch {
QTABQ set i [lsearch $sendiamalivelist $conn]
QTABQ set sendiamalivelist [lreplace $sendiamalivelist $i $i]
    }
}

proc sendiamalives {} {
    global sendiamalivelist sendiamaliveinterval

    after $sendiamaliveinterval sendiamalives
    foreach conn $sendiamalivelist {
QTABQ debugmsg KWOTESending iamalive to $connKWOTE
QTABQ catch {FloaterSend $conn *alive*}
    }
}

proc checkreceiveiamalive {conn} {
    global iamalivetimeout timeofmostrecent floaterclock

//  puts KWOTEcheckr. $connKWOTE
    catch {
QTABQ debugmsg KWOTEseconds since most recent msg on $conn: [expr ($floaterclock - $timeofmostrecent($conn))]KWOTE
QTABQ if [expr ($floaterclock - $timeofmostrecent($conn)) > $iamalivetimeout] \
QTABQ QTABQ {floatertimeout $conn}
    }
}

proc checkreceiveiamalives {} {
    global receiveiamalivelist receiveiamaliveinterval

    after $receiveiamaliveinterval checkreceiveiamalives
    foreach conn $receiveiamalivelist { checkreceiveiamalive $conn }
}

sendiamalives
checkreceiveiamalives

// MyTurnTimer -- the purpose of which is to refresh the display of
// the auction once every N seconds if it is my turn to bid and I
// havenkwertt bid yet.  This is an attempt to combat the mysterious bug
// whereby the auction sometimes disappears/fails to appear for no reason,
// perhaps due to a packer bug in Tk.

gset MyTurnTimer -99
tryset MyTurnTimerCountdown 20
proc startMyTurnTimer {} {
    global MyTurnTimerCountdown MyTurnTimer
    set MyTurnTimer $MyTurnTimerCountdown
}    

proc MyTurnTimerRing {} {
    global showingauction
    if $showingauction {
QTABQ showauction 0
QTABQ showauction 1
QTABQ startMyTurnTimer
    }
}

proc stopMyTurnTimer {} {
    global MyTurnTimer
    set MyTurnTimer -99
}

line 1335

// floaterclock

proc floaterclockbump {} {
    global floaterclock MyTurnTimer

    incr floaterclock
    if {$MyTurnTimer > 0} {if {[incr MyTurnTimer -1] == 0} MyTurnTimerRing}
    after 1000 floaterclockbump
    // every few seconds, issue null command to get tasks() called, etc.
    // (this is a hack and probably should be done via idletasks)
    if {[expr $floaterclock % 3] == 0} {command {}}
}

after 1000 floaterclockbump


proc countdown {x} {
    global $x

    if {[set $x] > 0} then KWOTEafter 1000 \KWOTEcountdown $x\KWOTEKWOTE else return
    incr $x -1
}

proc reset_rejoinnow {} {
    global rejoinclock rejoinclockincrement

    set rejoinclock 0
    set rejoinclockincrement 1
}

proc rejoinnow {} {
    global rejoinclock rejoinclockincrement

    if {$rejoinclock <= 0} then {
QTABQ if {$rejoinclockincrement < 1800} \
QTABQ QTABQ {set rejoinclockincrement [expr 2 * $rejoinclockincrement]}
QTABQ set rejoinclock $rejoinclockincrement
QTABQ countdown rejoinclock
QTABQ return 1
    } else {return 0}
}

proc reset_find_rho {} {
    global rhoclock rhoclockincrement

    set rhoclock 0
    set rhoclockincrement 1
}

proc findrhonow {} {
    global rhoclock rhoclockincrement

    if {$rhoclock <= 0} then {
QTABQ if {$rhoclockincrement < 1800} \
QTABQ QTABQ {set rhoclockincrement [expr 2 * $rhoclockincrement]}
QTABQ set rhoclock $rhoclockincrement
QTABQ countdown rhoclock
QTABQ return 1
    } else {return 0}
}

reset_find_rho
reset_rejoinnow

// whether we are currently waiting on an autodeal timer
gset autodealing 0

proc autonewdeal {} {
    global autonewdeal_seconds autodealing

    if $autodealing return
    if {$autonewdeal_seconds >= 0} {
QTABQ set autodealing 1
QTABQ after [expr 1000 * $autonewdeal_seconds] {
QTABQ     global autodealing
QTABQ     
QTABQ     if $autodealing {
QTABQ QTABQ set autodealing 0
QTABQ QTABQ if {$autonewdeal_seconds >= 0} {command autodeal_now}
QTABQ     } else {
#ifdef DEBUG
#ifndef TEXT
QTABQ QTABQ puts stderr KWOTEautodeal not performedKWOTE
#endif
#endif
QTABQ     }
QTABQ }
    }
}

/////////////////////////////////////////////////////////////////////////////
// Periodically updating the location
/////////////////////////////////////////////////////////////////////////////

global updateloc_seconds
tryset updateloc_seconds 300

proc updateloc {} {
    global updateloc_seconds

    after [expr 1000 * $updateloc_seconds] updateloc
    catch {command iupdatelocation}
}

updateloc




///////////////////////////////////////////////////////////////////////////////
// Deferring callbacks into Floaterkwerts C code because the C code isnkwertt reentrant
///////////////////////////////////////////////////////////////////////////////

// initially zero, but set by the C code---see proc defer below---when
//  it doesnkwertt want reentry
gset should_defer 0


proc command args {
    global should_defer

    if $should_defer {deferpush KWOTEcommandn $argsKWOTE} else {eval KWOTEcommandn $argsKWOTE}
}


#if 0
proc floateralive {conn} {
    global timeofmostrecent floaterclock

    debugmsg KWOTEReceived iamalive from $connKWOTE
    set timeofmostrecent($conn) $floaterclock // redundant, but cankwertt hurt
}
#endif

proc floaterreceive {msg conn} {
    global should_defer timeofmostrecent floaterclock

    set timeofmostrecent($conn) $floaterclock
    // if {$msg == KWOTE*alive*KWOTE} { floateralive $conn; return }
    if {$msg == KWOTE*alive*KWOTE} return

    if $should_defer {
QTABQ deferpush KWOTEfloaterreceiven {$msg} {$conn}KWOTE
    } else {
QTABQ floaterreceiven $msg $conn
    }
}

proc talk args {
    global should_defer

    if $should_defer {deferpush KWOTEtalkn $argsKWOTE} else {eval KWOTEtalkn $argsKWOTE}
}

proc FloaterClose args {
    global should_defer

    if $should_defer {deferpush KWOTEFloaterClosen $argsKWOTE} \
QTABQ     else {eval KWOTEFloaterClosen $argsKWOTE}
}

#if 0
proc requestresult args {
    global should_defer

    if $should_defer {deferpush KWOTErequestresultn $argsKWOTE} \
QTABQ     else {eval KWOTErequestresultn $argsKWOTE}
}
#endif

proc floatertimeout args {
    global should_defer

    if $should_defer {deferpush KWOTEfloatertimeoutn $argsKWOTE} \
QTABQ     else {eval KWOTEfloatertimeoutn $argsKWOTE}
}

/////////////////////////////////////////////////////////////////////////////
// implementation of a queue for deferred commands
/////////////////////////////////////////////////////////////////////////////

// Modifies the variable should_defer by adding n to it.
// If should_defer becomes 0 as a result, do the queue of deferred commands.
proc defer {n} {
    global should_defer

    if {[incr should_defer $n] == 0} {
QTABQ while {![deferempty]} {eval [deferpop]}
    }
}

gset deferqueuelo 0
gset deferqueuehi 0

proc deferempty {} {
    global deferqueuehi deferqueuelo

    return [expr $deferqueuelo == $deferqueuehi]
}

proc deferpush {s} {
    global deferqueue deferqueuehi
    
    set deferqueue($deferqueuehi) $s
    incr deferqueuehi
#ifdef DEBUG
    debugmsg KWOTEDeferring $sKWOTE
#endif
}

proc deferpop {} {
    global deferqueue deferqueuelo
    
    set temp $deferqueue($deferqueuelo)
    unset deferqueue($deferqueuelo)
    incr deferqueuelo
#ifdef DEBUG
    debugmsg KWOTEDeferpop $tempKWOTE
#endif
    return $temp
}

line 1548




/////////////////////////////////////////////////////////////////////////////
// Execute commands taken from a file
/////////////////////////////////////////////////////////////////////////////

set executing_index 0

proc Floater_execute {file} {
    global executing_index executing_command
    if {[set n [gets $file s]] >= 0} {
QTABQ if {$n > 0} {
QTABQ     deferpush KWOTEshow_executing [incr executing_index]; Floater_execute $fileKWOTE
QTABQ     set executing_command($executing_index) $s
QTABQ } else {
QTABQ     // Line just read is blank, so immediately go to the next line.
QTABQ     Floater_execute $file
QTABQ }
QTABQ return
    }
    catch {close $file}
}    

proc show_executing {n} {
    global executing_command

    talkmsg KWOTEExecute: $executing_command($n)KWOTE
    commandn $executing_command($n)
    unset executing_command($n)
}
/////////////////////////////////////////////////////////////////////////////
// Convention cards
/////////////////////////////////////////////////////////////////////////////

proc untabify {s} {
    if [regexp {([^\t]*)\t(.*)} $s whole left right] {
QTABQ set i [string length $left]
QTABQ while 1 {
QTABQ     set right KWOTE $rightKWOTE
QTABQ     incr i
QTABQ     if [expr $i % 8 == 0] {return [untabify $left$right]}
QTABQ }
    } else {return $s}
}

proc truncate {s {n 80}} {
    if {[string length $s] > $n} {
QTABQ return [string range $s 0 [expr $n - 1]]
    } else {
QTABQ return $s
    }
}

proc unbraceclean {s} {
    regsub -all {\\(\[|\]|\{|\})} $s {\1} x
    return $x
}

proc beginnewcc {direction} {
    global newcc newccline newccignoring

    set newccline 0
    set newccignoring 0
    set newcc $direction
}

proc fetchnewcc {ccloadfile} {
    while {[gets $ccloadfile s] >= 0} {addnewcc $s 0}
}

proc addnewcc {s {bracecleaned 1}} {
    global newcc newccline cc newccignoring

    set s [untabify [truncate $s]]
    if $bracecleaned {set s [unbraceclean $s]}
    if {$newccline == 40} {set newccignoring 1; return}
    set cc($newcc,[incr newccline]) $s
}

proc endnewcc {} {
    global newcc newccline newccignoring cclines

    set cclines($newcc) $newccline
    // The cc is stored in cc($newcc,1) through cc($newcc,$cclines($newcc))
    if $newccignoring {
QTABQ return KWOTEWarning: Ignored lines beyond the first 40KWOTE
    } else {
QTABQ return KWOTEKWOTE
    }
}

// String together all the lines of the cc for the named direction, using
// tabs as glue (because tabs are not allowed in a cc).
proc ccstr {direction} {
    global cc cclines

    set s KWOTEKWOTE
    catch {
QTABQ if {$cclines($direction) < 1} {return KWOTEKWOTE}
QTABQ set s $cc($direction,1)
QTABQ for {set i 2} {$i <= $cclines($direction)} {incr i} {
QTABQ     set s KWOTE$s\t$cc($direction,$i)KWOTE
QTABQ }
    }
    return $s
}

gset lastrange KWOTEKWOTE // for trivial memoization
proc inrange {n range} {
    global lastrange lastrangelow lastrangehigh // for trivial memoization

    if {$range != $lastrange} {
QTABQ set lastrange $range
QTABQ if [regexp {^([0-9]+)-([0-9]+)$} $range x lastrangelow lastrangehigh] {
QTABQ     // everythingkwerts all set
QTABQ } elseif [regexp {^([0-9]+)$} $range lastrangelow] {
QTABQ     set lastrangehigh $lastrangelow
QTABQ } elseif [regexp {^([0-9]+)-$} $range x lastrangelow] {
QTABQ     set lastrangehigh 1000000
QTABQ } elseif [regexp {^-([0-9]+)$} $range x lastrangehigh] {
QTABQ     set lastrangelow -1000000
QTABQ } else {error KWOTEInvalid range: $rangeKWOTE}
    }
    expr ($n >= $lastrangelow) && ($n <= $lastrangehigh)
}

proc ccdump {direction {range 1-}} {
    global cc cclines

    for {set i 1} {$i <= $cclines($direction)} {incr i} {
QTABQ if [inrange $i $range] {
QTABQ     talkmsg $cc($direction,$i)
QTABQ }
    }
}

proc ccsave {file direction} {
    global cc cclines

    for {set i 1} {$i <= $cclines($direction)} {incr i} {
QTABQ puts $file $cc($direction,$i)
    }
    close $file
}

proc getccline {direction line} {
    global cc cclines

    if ![info exists cclines($direction)] {return KWOTEKWOTE}
    if {$line <= $cclines($direction)} {
QTABQ return $cc($direction,$line)
    } else {
QTABQ return KWOTEKWOTE
    }
}

line 1697

/////////////////////////////////////////////////////////////////////////////
// Hack for printing a bunch of lines in reverse order (used for EW results)
/////////////////////////////////////////////////////////////////////////////

// Note that each reverse_init call must be matched by a reverse_done,
// with no reverse_init calls in between.
proc reverse_init {} {
    global reverse_n

    set reverse_n 0
}

proc reverse_print {s} {
    global reverse_n reverse_lines

    set reverse_lines($reverse_n) $s
    incr reverse_n
}

proc reverse_done {} {
    global reverse_n reverse_lines

    while {[incr reverse_n -1] >= 0} {
QTABQ talkmsg $reverse_lines($reverse_n)
QTABQ unset reverse_lines($reverse_n)
    }
}

/////////////////////////////////////////////////////////////////////////////
proc Floater_login {} {
    global loginname loginpassword newbie

    toplevel .login

    frame .login.left
    frame .login.right
    frame .login.bottom

    button .login.bottom.cancel -text KWOTECancelKWOTE \
QTABQ -command {set loginname KWOTEKWOTE; set loginpassword KWOTEKWOTE; destroy .login}
    button .login.bottom.clear -text KWOTEClearKWOTE \
QTABQ -command {set loginname KWOTEKWOTE; set loginpassword KWOTEKWOTE; focus .login.right.n}
    button .login.bottom.ok -text KWOTEOKKWOTE \
QTABQ -command {destroy .login}

    proc newbietr {name el op} {
QTABQ global pw_or_email newbie

QTABQ if $newbie {set pw_or_email KWOTEEmail address: KWOTE} \
QTABQ QTABQ {set pw_or_email KWOTEPassword: KWOTE}
    }

    checkbutton .login.new -text KWOTENew UserKWOTE -variable newbie
    trace variable newbie w newbietr
    if [info exists newbie] {set newbie $newbie} {set newbie 0}

    label .login.left.n -text KWOTEName: KWOTE
    label .login.left.p -textvariable pw_or_email -width 13

    entry .login.right.n -bd 2 -relief sunken -textvariable loginname
    focus .login.right.n
    entry .login.right.p -bd 2 -relief sunken -textvariable loginpassword

    pack .login.bottom.cancel .login.bottom.clear .login.bottom.ok \
QTABQ -side left -expand yes -fill x -padx 3m -pady 2m
    pack .login.left.n .login.left.p
    pack .login.right.n .login.right.p
    pack .login.bottom -side bottom
    pack .login.new -side bottom -pady 2m
    pack .login.left -side left -fill x -expand yes
    pack .login.right .login.right -side right -fill x -expand yes
    wm title .login KWOTEFloater loginKWOTE

    bindsetup .login.right.n .login.right.p {focus .login.right.p}
    bindsetup .login.right.p .login.right.n {destroy .login}
    bind .login.right.n \\ {set loginname KWOTEKWOTE}

    grab set .login
    tkwait window .login
    trace vdelete newbie w newbietr
    set loginname [string trim $loginname]
    catch focus_cmdline
    if $newbie {return KWOTEN$loginname\\$loginpasswordKWOTE} \
QTABQ     {return KWOTEO$loginname\\$loginpasswordKWOTE}
}

proc Floater_changepw {} {
    global changepwname oldpassword newpassword

    toplevel .changepw

    frame .changepw.left
    frame .changepw.right
    frame .changepw.bottom


    button .changepw.bottom.cancel -text KWOTECancelKWOTE \
QTABQ -command {set changepwname KWOTEKWOTE; set oldpassword KWOTEKWOTE; \
QTABQ set newpassword KWOTEKWOTE; destroy .changepw}
    button .changepw.bottom.clear -text KWOTEClearKWOTE \
QTABQ -command {set changepwname KWOTEKWOTE; set oldpassword KWOTEKWOTE; \
QTABQ set newpassword KWOTEKWOTE; focus .changepw.right.n}
    button .changepw.bottom.ok -text KWOTEOKKWOTE \
QTABQ -command {destroy .changepw}

    label .changepw.left.n -text KWOTEName: KWOTE
    label .changepw.left.o -text KWOTEOld password: KWOTE
    label .changepw.left.p -text KWOTENew password: KWOTE

    entry .changepw.right.n -bd 2 -relief sunken -textvariable changepwname
    entry .changepw.right.o -bd 2 -relief sunken -textvariable oldpassword
    entry .changepw.right.p -bd 2 -relief sunken -textvariable newpassword

    pack .changepw.bottom.cancel .changepw.bottom.clear .changepw.bottom.ok \
QTABQ -side left -expand yes -fill x -padx 3m -pady 2m
    pack .changepw.left.n .changepw.left.o .changepw.left.p
    pack .changepw.right.n .changepw.right.o .changepw.right.p
    pack .changepw.bottom -side bottom
    pack .changepw.left -side left -fill x -expand yes
    pack .changepw.right .changepw.right -side right -fill x -expand yes
    wm title .changepw KWOTEchange passwordKWOTE

    bindsetup .changepw.right.n .changepw.right.o {focus .changepw.right.o}
    bindsetup .changepw.right.o .changepw.right.p {focus .changepw.right.p}
    bindsetup .changepw.right.p .changepw.right.n {destroy .changepw}
    bind .changepw.right.n \\ {set changepwname KWOTEKWOTE}

    grab set .changepw
    tkwait window .changepw
    catch {focus .cmd; focus .cmd.talk}
    return KWOTE$changepwname\\$oldpassword\\$newpasswordKWOTE
}



proc Floater_bell {} { catch { bell } }
#-yisu
showEntryLines both

line bottom


